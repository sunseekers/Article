const path=require('path')
module.exports={
  //entry表示入口，webpack执行构建的第一步将从Entry开始，可抽象成输入
  //类型可以是 string，object，array
  entry:'./app/entry',//只有一个入口，入口只有一个文件
  entry:['./app/entry1','./app/entry2'],//只有一个入口，入口有两个文件
  entry:{//与两个入口
    a:'./app/entry-a',
    b:['./app/entry-b1','./app/entry-b2']
  },
  //如何输出结果，在webpack经过一系类处理后，如何输出最终想要的代码
  output:{
    //输出文件放的目录，必须是string类型的绝对路径
    path:path.resolve(__dirname,'dist'),
    //输出文件的名称
    filename:'bundle.js',//完整的名称
    filename:'[name].js',//在配置了多个entry时，通过名称模板为不同的entry生成不同的文件名称
    filename:'[chunkhash].js',//根据文件内容的Hash值生成文件的名称，浏览器长时间缓存文件
    //发布到线上的所有资源的URL前缀，为string
    publicPath:'./assets/',//放到指定目录下
    publicPath:'',//放到根目录下
    publicPath:'https://cdn/example.com',//放到CDN上
    //到出库的名称，为string，不填他时，默认的输出格式是匿名的立即执行函数
    library:'MyLibrary',
    //导出库的类型，为枚举类型，默认是var
    //numd,num2,commonjs2,commonjs,amd,this,var,assign,window,global,jsonp,可以是这些类型
    libraryTarget:'umd',
    //是否包含有用的文件路径信息到生成代码里，为booleanleix
    pathinfo:true,
    //附加chunk的文件名称
    chunkFilename:'[id].js',
    chunkFilename:'[chunkhash].js',
    //JSON异步加载资源时回调函数名称，需要和服务端搭配
    jsonpFunction:'myWebpackJsonp',
    //生成Source Map文件的名称
    sourceMapFilename:'[file].map',
    //浏览器开发者工具里面显示的资源模块名称
    devtoolModuleFilenameTemplate:'webpack:///[resouce-path]',
    //异步加载跨域的资源时使用的方式
    crossOriginLoading:'use-credentials',
    crossOriginLoading:'aninymous',
    crossOriginLoading:'false',
  },
  //配置模块相关
  module:{
    rules:[//配置Loader
      {
        test:/\.jsx?$/,//正则匹配命中要使用Loader的文件
        include:[//只会命中这里面的文件
          path.resolve(__dirname,'app')
        ],
        exclude:[//忽略这里面的文件
          path.resolve(__dirname,'app/demo-files')
        ],
        use:[//使用哪些Loader,有先后次序，从后往前
          'style-loader',//直接使用Loader的名称
          {
            loader:'css-loader',
            options:{
              //向html-loader传一些参数
            }
          }
        ]
      }
    ]
  }
}